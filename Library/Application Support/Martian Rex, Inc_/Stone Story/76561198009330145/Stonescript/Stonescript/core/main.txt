var AAC = import Stonescript/core/logic/aac
var C = import Stonescript/core/variables/constants
var Colors = import Stonescript/core/utils/colors
var Debuger = import Stonescript/observability/debugger
var HashTable = import Stonescript/core/utils/hash-table
var Potion = import Stonescript/core/logic/potion
var SafeMean = import Stonescript/core/logic/safe-mean
var Tracer = import Stonescript/observability/tracer
var Unmake = import Stonescript/core/logic/unmake

/*===================== PROGRESSION =====================*/
func progress()
  /*===== PICKUP RESOURCES =====*/
  ?pickup.distance < 9
    return equip_L("star") & equip_R("trisk")
  /*========== SMITE ==========*/
  ?C.long_long_smite & smite_two_screens()
    return true
  /*========= PASSIVE =========*/
  ?healwalk()
    return true
  /*======= DODGE EXPLO =======*/
  ?foe = explode
    return avoid_explosion()
  /*======= RESERVE STUN =======*/
  ?loc = caves
    check_stunlock()
  /*===== REGULAR ENEMIES =====*/
  ?!is_boss & !at_boss
    free_mind = true
    return regular_fight()
  /*==== MINIBOSSES/BOSSES ====*/
  Tracer.span("boss")
  disable_r("skeleton_arm")

  ?loc = rocky
    ?foe_id = "acronian_scout"
      Tracer.span("miniboss")
      disable_r("hammer")
      return fight_scout()
    return fight_dysan()

  :?loc = deadwood
    return fight_xyloalgia()

  :?loc = caves
    ?is(foe_id, "cool_bat")
      Tracer.span("miniboss")
      ?can_stunlock & C.do_stunlock.Contains("ceiling decorator")
        disable_r("mask")
        disable_r("blade")
        disable_r("bardiche")
        return stunlock()
      return auto_melee_miniboss()
    :
      return fight_bolesh()

  :?loc = fungus_forest_boss
    return fight_mushrooms()

  :?loc = mushroom & is(foe_id, "epic_snail")
    disable_r("bardiche")
    disable_r("hammer")
    disable_r("bash")
    return auto_melee_miniboss()

  :?loc = undead_crypt_boss
    return fight_pallas()

  :?loc = halls
    Tracer.span("miniboss")
    ?foe = ghost_tomb
      return melee("dps")
    :
      return ranged("aoe")

  :?loc = bronze_guardian
    return fight_bronze_guardian()

  :?loc = icy_ridge
    ?foe_id = "ice_elemental_elite"
      ?!at_boss
        Tracer.span("miniboss")
        ?can_stunlock & C.do_stunlock.Contains("ice elemental")
          disable_r("mask")
          disable_r("blade")
          disable_r("hammer")
          return stunlock()
        :
          disable_r("hammer")
          return auto_melee_miniboss()
      :
        return ranged("aoe")
    return fight_hrimnir()

  :?loc = temple & is(foe_id, "acronian_cultist")
    Tracer.span("miniboss")
    excluded_items = "vigor"
    return auto_melee_miniboss()

  :?loc = nagaraja
    return fight_nagaraja()

  :
    Debugger.handle("Fighting unknown boss: " + foe_id)
    auto_melee_boss()

func healwalk()
  Tracer.span("healwalk")
  ?foe & (foe_distance < 23)
    ?hp < (maxhp / 4) & item.potion ! empty & (item.potion = "healing" | item.potion = "vampiric")
      activate potion
    return false // Start combat instead.
  :?C.harvesting & harvest.distance < 3 & _harvest()
    return true
  :?should_summon()
    return equip_L("trisk") & summon()
  :?can_qs_dash()
    return qs_dash()
  auto_equip_shield()
  ?hp < maxhp & !lucky_crit
    return equip_L("ouroboros")
  return equip_L("trisk")

// `harvest` is a reserved keyword :(.
func _harvest()
  ?loc = Rocky
    return equip_L("shovel")
  :?loc = Deadwood
    equip_R("hatchet")
    ?harvest.distance < 2
      use("hatchet")
    return true
  return false

func avoid_explosion()
  Tracer.span("explode")
  ?foe_distance < 5
    return try_evade()
  return auto_equip_L("melee", false) & equip_R("dashing")

var scrolling = 0
func smite_two_screens()
  var cd_ok = get_cd("blade") <= 0
  ?cd_ok & foe_count > 3
    scrolling++
    screen.Next()
  :
    scrolling = 0
    screen.ResetOffset()
  ?foe_ehp < 600 & foe_ehp > 0 & cd_ok & foe_distance < 25 & (foe_count > 5 | scrolling > 15)
    return smite()
  return scrolling > 0

/*===================== BOSSES =====================*/
func try_evade()
  Tracer.span("try_evade")
  ?can_mind
    set_lock("mind", 2)
    return backflip()
  return hard_block()

func hard_block()
  Tracer.span("hard_block")
  return equip_L("quest") & equip_R(C.evade_shield)

func evade_at(t)
  Tracer.span("evade_at")
  ?foe_time >= t
    return try_evade()
  ?foe_time < t & get_cd("mind") <= (t - foe_time)
    // Abilities that would be interrupted.
    ?foe_time > (t - C.bardiche_frames)
      disable_r("bardiche")
    ?foe_time > (t - C.heavy_hammer_frames)
      disable_r("hammer")
  return false

func soft_block()
  Tracer.span("soft_block")
  ?lock //Don't interrupt abilities.
    return false
  return equip_R(C.evade_shield)

func around(t)
  return foe_time > (t-2) & foe_time < (t+2)

func fight_scout()
  lucky_crit = false
  auto_melee_miniboss()

var last_state = 0
var dysan_step = -1
func fight_dysan()
  disable_r("skeleton_arm")
  var delay = chill_delay()
  var hit = 28
  ?loc_stars > 10
    hit = 22
  ?foe = phase1
    disable_r("blade")
    disable_r("cinderwisp")
    Potion.try_drink()
    ?(foe_state = 33 & foe_time = 23) | (foe_state = 32 & around(hit + delay))
      return soft_block()
  :?foe = phase2
    disable_r("cinderwisp")
    // FIXME: Not working.
    // If bfg R tight timing works, will switch back to mask during phase 2 => 3 animation.
    // ?foe_state = 107
    //   found = "mask"
    //   return equip_R(found)
    // ?smite_at_exact() | dash_closer() | (foe_state = 33 & use_abilities())
    //   return true
    ?dash_closer()
      return true
    Tracer.span("match_element")
    found = false
    ?should_debuff()
      found = find_debuff_weapon("melee", false, debuff_elems[0], false)
      ?found
        return equip_L(found)
    auto_equip_L("melee", false)
    ?foe_state = 32 & around(58 + delay)
      return soft_block()
    ?lucky_crit
      found = "mask"
      ?found
        return equip_R(found)
    :
      found = false
      ?should_debuff()
        found = find_debuff_weapon("melee", false, debuff_elems[0], false)
      ?found
        return equip_R(found)
      return auto_equip_R("melee", false)
  :?foe = phase3
    disable_r("blade")
    // Prevent healing.
    low_hp = false
    weak_elem = "default"
    hit = 20 + math.Max(0, delay-6)
    // Hammer him right as he gets armor.
    ?foe_state=32 & foe_time>hit & dysan_step=0 & foe_distance > 10 & can_hammer()
      return hammer()
    // Don't use element he's guarding against.
    var resist = foe_buff("adaptive_defense")
    ?!(low_hp & is(resist, "vigor"))
      excluded_items = resist
    // His attack order is cyclical, so we can dodge both the stun and the ray.
    ?(last_state = 32 & foe_state = 33) | (last_state = 33 & foe_state = 2) | (last_state = 2 & foe_state = 32)
      dysan_step++
    :?(foe_state!32) & (foe_state!33) & (foe_state!2)
      dysan_step = 0
    last_state = foe_state
    ?foe_state = 32 & dysan_step >= 6 & evade_at(hit)
      // Dodge the stun.
      dysan_step = 0
      return
    :?foe_state=115 & foe_time<=70 & evade_at(70)
      // Dodge the ray, don't dash back into it.
      return set_lock("boss", 7)
    :?foe_state = 32 & (dysan_step < 7) & around(48 + delay)
      return soft_block()
    :?lucky_crit & !lock // Prevent hammer R interuption.
      found = "mask"
      equip_R(found)
  auto_melee_boss()

func fight_xyloalgia()
  disable_r("skeleton_arm")
  var stunlock_poena = loc_stars > 5 & can_stunlock & C.do_stunlock.Contains("poena")
  ?foe = phase1
    ?Potion.fast_potion_bosses.Contains("xylo")
      Potion.try_drink()
    ?stunlock_poena
      // Save abilities for poena.
      disable_r("mask")
      disable_r("hammer")
      disable_r("blade")
      disable_r("bardiche")

    ?foe_state = 32 & evade_at(31 + chill_delay())
      return

    auto_melee_boss()
  :?foe = phase2
    ?unsummon()
      return
    excluded_items = "dU"
    ?stunlock_poena
      stunlock()

    // no stunlocking, avoid hitting the mirror
    :?(disable_debuffs & foe.hp>(foe.maxhp/4)) | (foe_state = 32 & foe_time = 41)
      hard_block()
    :
      auto_melee_boss()

func fight_bolesh()
  /* Get close, debuff/use abilities, then
  jump to ranged before the first melee bite,
  and continue shooting and blocking. */
  ?foe_state = 133 & (around(11) | around(16))
    //block the bite and don't move from ranged
    hard_block()

  :?foe_state = 142 & evade_at(60)
    // evade melee bite
    return

  :?can_mind & !foe_buff("spider_buff_damage")
    Potion.try_drink()
    return use_abilities() | auto_melee_boss()
  :
    auto_melee_boss()
    // ranged("single")

func fight_mushrooms()
  var delay = chill_delay()
  ?foe = phase1
    disable_r("bardiche")
    ?Potion.fast_potion_bosses.Contains("mushrooms")
      Potion.try_drink()
    disable_r("skeleton_arm")
    ?foe_state = 32 & evade_at(46 + delay)
      return
    :?foe_state = 33 & foe_time=foe_distance+4
      return soft_block() // pellets
  :?foe = mushroom_boss_fat
    Potion.try_drink()
    ?foe_state = 32 & evade_at(26 + delay)
      return
  auto_melee_boss()

func fight_pallas()
  disable_r("skeleton_arm")
  ?foe = phase1
    ?Potion.fast_potion_bosses.Contains("pallas")
      Potion.try_drink()
    ?foe_state = 32 & foe_time = 68
      soft_block()
    :
      auto_melee_boss()
  :?foe = phase2
    Potion.try_drink()
    ?foe_count > 2
      return ranged("aoe") // deal with ghosts
    auto_melee_boss()

func fight_bronze_guardian()
  disable_r("blade")
  disable_r("bardiche")

  ?foe_state = 32 & foe_time = 33 & armor < foe.damage
    backflip() // dodge the hammer
  :?foe_state = 33 // hammer is down
    Potion.try_drink()
    auto_melee_boss()
  :
    ?foe_armor > 0 & foe_distance <= 21 & item.GetCooldown("hammer") <= 0 | item.GetCooldown("hammer") >= 647
      equip heavy hammer
      ?item.CanActivate()
        activate R
    :
      Potion.try_drink()
      ranged("single")

func fight_hrimnir()
  at_boss = true
  ?is_snowball_near() | (is_boss & foe_distance <= 6 & foe_state = 32 & around(23 + chill_delay()))
    // snowballs
    ?C.useable_abilities.Contains("fire_talisman")
      equip_L("fire talisman")
    soft_block()
  :?draw.GetSymbol(56, 13) = "o" | is_boss & foe_state = 133 // blowing
    ?foe_count > 1
      ranged("aoe")
    :
      ranged("single")
  :?is_boss & foe_state = 132 & foe_time > 24
    set_lock("boss", 2) // preparing to blow
    auto_melee_boss()
  :?is_boss & foe_state = 142 & foe_time > 83
    set_lock("boss", 2) // blowing + summons
    ?foe_count > 1
      ranged("aoe")
    :
      ranged("single")
  :?is_boss & foe_count = 1
    ?foe_armor > 0
      ?can_hammer()
        return hammer()
      return melee("dps")
    Potion.try_drink()
    auto_melee_boss()
  :?foe_distance < 8
    auto_melee()
  :
    auto_melee_boss()

var dists = [3, 4]
func is_snowball_near()
  var x = screen.FromWorldX(pos.x)
  var y = screen.FromWorldZ(pos.z)
  for dist : dists
    ?draw.GetSymbol(x+dist, y-3) = "(" & draw.GetSymbol(x+dist+1, y-3) = "_" & draw.GetSymbol(x+dist+2, y-3) = ")"
      return true
  return false

var naga_step = 0
func fight_nagaraja()
  disable_r("blade")
  ?Potion.fast_potion_bosses.Contains("naga")
    Potion.try_drink()
  var to_dodge = 1
  ?loc_stars > 10
    to_dodge = 4
  :?loc_stars > 5
    to_dodge = 2
  // Dodge poison balls & plink away.
  ?is_poison_near()
    ?naga_step <= to_dodge
      // We're still at range, use qs.
      ?can_mind & foe_distance < 12
        naga_step = 0
        Potion.try_drink()
        auto_melee_boss()
      :
        naga_step++
        qs_dash()
    :
      // Now we're in melee.
      evade_naga()
  // Boulder.
  :?foe_state = 112 & foe_time = 59 & foe_distance < 10
    evade_naga()
  :?naga_step <= to_dodge
    /* to split-frame dash with quarterstaff,
    we need to be equipped with a 2h weapon the
    frame before. So we try not to use wands if
    possible. */
    ?use_abilities()
      return
    ?foe_state = 32 | foe_state = 33 | ((foe_state = 101 | foe_state = 112) & foe_time < 20)
      excluded_items = "wand"
      found =find_dps_weapon("ranged",false,true)
      ?found
        return equip_L(found)
      excluded_items = false
    ranged("single")
  :
    Potion.try_drink()
    auto_melee_boss()

func evade_naga()
  ?can_mind
    naga_step = 0
    return backflip() // Dodge back.
  :
    return soft_block() // Try to block.

func is_poison_near()
  var x = screen.FromWorldX(pos.x)
  var y = screen.FromWorldZ(pos.z)
  //     Long and mid range       |        Melee.
  return draw.GetSymbol(x+2, y-6) = "(" | (draw.GetSymbol(x+1, y-6) = "(")

/*===================== COMBAT =====================*/
func regular_fight()
  Tracer.span("fight")
  ?must_ranged_foe()
    return ranged("single")
  ?foe = immune_to_ranged | foe = ranged
    return auto_melee()
  return auto_melee()

func must_ranged_foe()
  for enemy: C.must_ranged_foes
    ?foe = enemy
      return true

func auto_melee()
  Tracer.span("auto_m")
  ?use_abilities()
    return true
  :?can_aoe & foe_distance <= melee_aoe_range
    return melee("aoe")
  :?low_hp & C.use_shield_on_low_hp
    return melee("def")
  return melee("dps")

// mode: "dps" | "def" | "aoe".
func melee(mode)
  Tracer.span("m_" + mode)
  ?dash_closer()
    return true
  var aoe = is(mode, "aoe")
  ?Unmake.should_unmake()
    // >`10,10,should_unmake
    ?try_equip_unmake(C.unmake_range, aoe)
      // >`11,10,try_equip_unmake
      Tracer.span("unmaking")
      mode = "unmake"
      return approach()
  :?should_debuff()
    ?try_equip_debuff("melee", aoe)
      Tracer.span("debuff")
      mode = "debuff"
      return approach()
  ?is(mode, "def")
    auto_equip_L("melee", false)
    ?C.use_shield_on_low_hp
      auto_equip_shield()
    auto_equip_R("melee", false)
  :
    auto_equip_dps("melee", aoe)
  return approach()

// TODO: More aggressive dash.
func approach()
  var range = 6
  ?found_type
    range = HashTable.get(weapon_ranges, found_type) + 1
  ?foe_distance > range
    Tracer.span("approach")
    // Use a shield while walking closer.
    ?!is_2hander(found_type)
      auto_equip_shield()
  return true

func dash_closer()
  Tracer.span("dash_closer")
  ?can_dash()
    return dash()
  :?should_qs_dash()
    return qs_dash()
  return false

func auto_ranged()
  Tracer.span("auto_r")
  ?C.for_ranged_single_target.Count() > 0 & smite_stacks > 6
    // FIXME: Will be an issue when multiple staves.
    return ranged("staff")
  ?use_abilities()
    return true
  :?can_aoe & C.for_ranged_aoe.Count() > 0 & foe_distance <= ranged_range
    return ranged("aoe")
  :?C.for_ranged_single_target.Count() > 0
    return ranged("single")
  return auto_melee()

// mode: aoe | single | staff.
func ranged(mode)
  Tracer.span("r_" + mode)
  var aoe = is(mode, "aoe")
  ?is(mode,"staff")
    return equip_L("staff")
  ?!aoe & must_ranged_foe() & C.for_ranged_single_target.Contains("repeating")
    return equip_L("repeating")
  ?Unmake.should_unmake()
    ?try_equip_unmake(C.unmake_range, aoe)
      Tracer.span("unmaking")
      mode = "unmake"
  :?should_debuff()
    ?try_equip_debuff("ranged", aoe)
      return
  return auto_equip_dps("ranged", aoe)

func auto_melee_boss()
  Tracer.span("auto_m_boss")
  ?use_abilities() | dash_closer()
    return true
  ?Unmake.should_unmake() & try_equip_unmake("melee", false)
    Tracer.span("unmaking")
    return approach()
  :?should_debuff()
    ?try_equip_debuff("melee", false)
      Tracer.span("debuff")
      return approach()
  auto_equip_dps("melee", false)
  return approach()

func auto_melee_miniboss()
  Tracer.span("auto_m_miniboss")
  ?foe_id = "acronian_scout"
    // Use mask R.
    return disable_r("blade") & disable_r("cinderwisp") & auto_melee()
  :
    return disable_r("blade") & disable_r("mask") & disable_r("cinderwisp") & auto_melee()

var can_stunlock = C.do_stunlock.Count() > 0 & C.stunlock_weapons.Count() > 0

func check_stunlock()
  ?can_stunlock & foe_id ! "cool_bat" & C.do_stunlock.Contains("ceiling decorator")
    // Save the stun for the bat.
    disable_r("hammer")

func stunlock()
  Tracer.span("stunlock")
  disable_r("skeleton_arm")
  ?dash_closer()
    return true
  ?disable_debuffs
    return Potion.try_drink() & melee("dps")
  // Now stunlock, and use abilities when it's safe.
  var stunned = foe_debuff("stun")
  ?(can_hammer() & foe_distance <= 17) | is(lock, "hammer")
    return hammer() // Long stun.
  :?(stunned > C.bardiche_frames + 10) & should_bard() | is(lock, "bardiche")
    return bardiche()
  :?stunned > 10
    ?should_cinder()
      return cinder()
    ?should_smite()
      return smite()
    ?should_mask()
      return mask()
  :?stunned <= 3
    ?get_cd("bash") <= 0 & foe_distance < 10 & foe_ehp > 100 & can_backflip()
      return backflip()
    ?can_qs_dash()
      return qs_dash()
  // Default stunlock action.
  found = false
  for it : C.stunlock_weapons
    ?!found & !(it = excluded_items) & !(it = foe_elem)
      found = it
  ?found
    equip_L(found)
  :
    equip_L(C.stunlock_weapons[0])
  found = false
  ?Unmake.should_unmake()
    found = find_unmake_weapon("melee", false, false)
  :?should_debuff()
    found = find_debuff_weapon("melee", false, debuff_elems[0], false)
  ?found
    equip_R(found)
  :
    auto_equip_R("melee", false)

/*===================== WEAPON SWITCHING =====================*/
var _equip_L = false
func equip_L(it)
  // Sets global flag, so the next `get_item()` in this frame won't return the same item.
  _equip_L = it
  ?is(it, C.qs_name)
    equip @it@
  :?is_2hander(it) | is_2hander(found_type)
    equip @it@
  :
    equipL @it@
  return it

var _equip_R = false
func equip_R(it)
  // For debug.
  _equip_R = it
  ?is_2hander(it) | is_2hander(found_type)
    equip @it@
  :
    equipR @it@
  return it

func is_2hander(ty)
  return ty & all_2h_types.Contains(ty)

// range: "melee" | "ranged", aoe: true/false.
func auto_equip_L(range, aoe)
  Tracer.span("auto_eq_L")
  found = find_dps_weapon(range, aoe, true)
  >`20,20,auto_equip_L: @found@
  ?found
    return equip_L(found)
  return false

// range: "melee" | "ranged", aoe: true/false
func auto_equip_R(range, aoe)
  Tracer.span("auto_eq_R")
  found = find_dps_weapon(range, aoe, false)
    >`21,21,auto_equip_R: @found@
  ?found
    return equip_R(found)
  return auto_equip_shield()

func auto_equip_shield()
  Tracer.span("auto_eq_sh")
  ?lucky_crit
    Tracer.span("auto_eq_sh_mask")
    equipR mask
  :
    found = false
    found_type = false
    ?low_hp
      found=get_item("shield", "vigor", "mod")
    ?!found
      ?is(weak_elem, "default") & player_armor >= C.speed_armor_coumpound_threshold
        found=C.max_armor_compound_shield
      :
        found=get_item("shield", weak_elem, "stats")
    ?!found
      found=get_item("shield", "default", "")
    ?found
      return equip_R(found)
    return false

// range: "melee" | "ranged", aoe: true/false.
func auto_equip_dps(range, aoe)
  Tracer.span("auto_eq_dps")
  // Lucky pot + mask strat.
  ?lucky_crit
    Tracer.span("dps_mask")
    found = find_dps_weapon(range, aoe, true)
    // Why +13 instead of +16
    ?!found
      return false
    equip_L(found)
    found = "mask"
    equip_R(found)
  :
    found = find_dps_weapon(range, aoe, true)
    ?!found
      return false
    equip_L(found)
    ?is_2hander(found_type)
      return found
    found = find_dps_weapon(range, aoe, false)
    ?found
      return equip_R(found)
    return false

func find_dps_weapon(range, aoe, allow_2h)
  Tracer.span("find_dps_weapon")
  found = false
  ?low_hp
    // Heal on low hp.
    found = find_weapon(range, aoe, "vigor", "mod", allow_2h)
  ?!found
    // Default case: match element.
    found = find_weapon(range, aoe, weak_elem, "stats", allow_2h)
  Tracer.span("" + found)
  return found

func try_equip_debuff(range, aoe)
  Tracer.span("try_eq_debuff")
  found = false
  // Lucky pot + mask strat.
  ?lucky_crit
    Tracer.span("debuff_mask")
    for elem:debuff_elems
      found = find_debuff_weapon(range, aoe, elem, false)
      ?found
        equipR mask
        // TODO: Probably useless.
        _equip_R = "mask"
        return equip_L(found)
  :
    for elem:debuff_elems
      // TODO: Find a way.
      // ?foe_id ! dysangelos & elem = "poison"
      //   return true
      // :
      found = find_debuff_weapon(range, aoe, elem, !_equip_L)
      ?found
        ?!_equip_L
          equip_L(found)
          ?is_2hander(found_type)
            return true
        :?!_equip_R
          ?low_hp
            return auto_equip_R(range, aoe)
          return equip_R(found)
  ?_equip_L
    ?!_equip_R
      return auto_equip_R(range, aoe)
  :
    Tracer.span("no_debuff_weapon")
    return false
  return true

func find_debuff_weapon(range, aoe, elem, allow_2h)
  Tracer.span("find_debuff_wep")
  found = find_weapon(range, aoe, elem, "mod", allow_2h)
  ?!found & range = "melee" & !(foe = immune_to_ranged | foe = ranged)
    found = find_weapon("ranged", aoe, elem, "mod", allow_2h)
  return found

func try_equip_unmake(range, aoe)
  Tracer.span("try_eq_unmake")
  found = find_unmake_weapon(range, aoe, true)
  ?!found
    aoe = false
    found = find_unmake_weapon(range, aoe, true)
  ?!found
    Tracer.span("no_unmake_weapon")
    return false
  equip_L(found)
  ?is_2hander(found_type)
    return true
  ?low_hp
    return auto_equip_R(range, aoe)
  found = find_unmake_weapon(range, aoe, false)
  ?found
    return equip_R(found)
  return auto_equip_R()

func find_unmake_weapon(range, aoe, allow_2h)
  Tracer.span("find_unmake_wep")
  found = find_weapon(range, aoe, "aether", "mod", allow_2h)
  ?!found & range = "melee"
    found = find_weapon("ranged", aoe, "aether", "mod", allow_2h)
  return found

func find_weapon(range, aoe, elem, purpose, allow_2h)
  found = false
  found_type = false
  var types = get_preferred_types(range, aoe)
  for ty : types
    ?allow_2h | !is_2hander(ty)
      ?!elem_types.Contains(ty) & !is(purpose, "mod")
        found_type = ty
        return ty
      found = get_item(ty, elem, purpose)
      ?!found & purpose = "stats"
        found = get_item(ty, "default", "")
      ?found
        found_type = ty
        return found
  return false

func get_preferred_types(range, aoe)
  ?phys_immune | (can_aoe & foe = magic_vulnerability)
    return C.for_phys_immune
  var types = C.for_melee_single_target
  // Remove the use of hammer during Dysan phase 3.
  // TODO: remove this when double +21 elem hammer.
  ?lucky_crit
    return types
  :
    ?is(range, "melee")
      ?foe_armor > 0
        ?aoe
          types = aa_aoe_types
        :
          types = aa_st_types
      :?aoe
        types = C.for_melee_aoe
    :
      ?aoe
        types = C.for_ranged_aoe
      :
        types = C.for_ranged_single_target
    return types

var excluded_items = ""
func get_item(ty, elem, purpose)
  var h
  ?is(elem, "default")
    h = hash([ty, "default"])
  :
    h = hash([ty, elem, purpose])
  var items = HashTable.try_get(all_items, h, false)
  ?!items | items.Count() = 0
    return false
  for it : items
    ?(!_equip_L | !is(it, _equip_L)) & (!excluded_items | !(it = excluded_items))
      return it
  return false

var only_dot = false
func can_debuff()
  only_dot = false
  ?disable_debuffs
    return false
  ?is_boss
    ?loc = Rocky // Always debuff Scout & Dysan.
      return true
    ?is(C.debuff_bosses_mode, "never")
      return false
    ?is(C.debuff_bosses_mode, "smite") & smite_stacks = 0
      ?can_be_debuffed("debuff_dot")
        only_dot = true // Keep up the dot.
        return true
      return false
  ?!is_boss & (is(C.debuff_non_bosses_mode, "never")
  ^| is(C.debuff_non_bosses_mode ,"smite") & smite_stacks = 0)
    return false
  return true

var disable_debuffs = false
var debuff_elems = []
func should_debuff()
  // TODO: Find a scalable way
  ?foe_id = "skeleton_boss_harder_2"
    return false
  ?!can_debuff()
    return false
  debuff_elems.Clear()
  ?can_be_debuffed("debuff_dot") & smite_stacks > 0
    debuff_elems.Add("fire")
    ?only_dot
      return true
  // TODO: Find a scalable way.
  //                           Don't debuff ice during Dysan p2.
  ?can_be_debuffed("debuff_chill") & foe_id ! "dysangelos_elementalist"
    debuff_elems.Add("ice")
  ?can_be_debuffed("debuff_damage") & C.do_debuff_damage.Contains(foe_id)
    debuff_elems.Add("poison")
  var c = debuff_elems.Count()
  ?c > 1 & foe = debuff_elems[0]
    var move = debuff_elems[0]
    debuff_elems[0] = debuff_elems[c-1]
    debuff_elems[c-1] = move
  return c > 0

func can_be_debuffed(debuff_uid)
  ?(foe = "immune_to_" + debuff_uid)
    return false
  ?is(debuff_uid, "debuff_chill")
    var c = foe_debuff("debuff_chill")
    return c < C.max_chill_stacks
  return !foe_debuff(debuff_uid)

/*===================== ABILITIES =====================*/
func get_cd(ability)
  return HashTable.try_get(cooldowns, ability, 9999)

func allowed(ability)
  return HashTable.try_get(abilities, ability, false)

func set_lock(tag, timer)
  ?!lock | (is(tag,"boss") & lock_timer < timer)
    lock = tag
    lock_timer = timer
  return true

func can_use(ability)
  ?lock
    return is(lock, ability)
  return allowed(ability)

func can_activate()
  return ai.enabled & item.CanActivate()

func use(ability)
  ?item.CanActivate(ability)
    activate R
  return true

func can_dash()
  return can_activate() & (can_use("dash") | can_use("bash") & !disable_debuffs)
  ^& foe_distance > 10 & foe_distance < 16

func dash()
  Tracer.span("dash")
  ?!disable_debuffs & can_use("bash")
    Tracer.span("bashing")
    return equip_R("bashing")
  :?can_use("dash")
    Tracer.span("dashing")
    return equip_R("dashing")
  return false

func can_qs_dash()
  return can_use("quarterstaff") & can_activate()

func should_qs_dash()
  return (foe_distance > 16 | foe_distance < 11 & foe_distance > 5) & can_qs_dash()

func qs_dash()
  Tracer.span("qs_dash")
  equip_L("quarterstaff")
  return use("quarterstaff")

func can_backflip()
  return can_use("mind") & free_mind &
   // Don't jump into the wall.
  ^screen.FromWorldX(pos.x) > 5

func backflip()
  Tracer.span("backflip")
  auto_equip_shield()
  return equip_L("mind")

func can_slap()
  return can_use("skeleton_arm") & !(foe_id = "ice_pillar") & foe_distance < 7 & !phys_immune & can_activate()

func should_slap()
  return can_slap() & foe_ehp <= C.arm_damage

func slap()
  Tracer.span("slap")
  ?pickpocket_stacks < C.max_pickpocket_stacks
    return equip_L("arm")
  equip_L("arm")
  return use("skeleton_arm")

func can_smite()
  return can_use("blade") & foe_distance <= 20 & (foe ! pallas) & can_activate()

func should_smite()
  return (is_boss | foe_count >= C.smite_threshold & foe_ehp <= C.smite_damage) & can_smite()

func smite()
  Tracer.span("smite")
  equip_L("blade")
  return use("blade")

func smite_at_exact()
  disable_r("blade")
  ?foe.hp <= C.smite_damage & get_cd("blade") <= 0
    return smite()
  return false

func can_hammer()
  return can_use("hammer") & !phys_immune & foe_distance <= 21 & can_activate()

func should_hammer()
  ?!can_hammer()
    return false
  return is(lock, "hammer") | (is_boss | can_aoe & foe_distance < 15)
  ^& (foe_armor > 0 | foe = spawner | can_debuff() & !(foe = immune_to_stun))

func hammer()
  Tracer.span("hammer")
  set_lock("hammer", C.heavy_hammer_frames)
  equip_L("heavy hammer")
  return use("hammer")

func can_bard()
  return can_use("bardiche") & foe_distance <= 9 & !phys_immune & can_activate()

func should_bard()
  return is(lock, "bardiche") | is_boss & !aspd_down & (foe_ehp >= (C.bardiche_dmg * 2) |
  ^foe_ehp < C.bardiche_dmg) & can_bard()

func bardiche()
  Tracer.span("bardiche")
  set_lock("bardiche", C.bardiche_frames)
  equip_L("bardiche")
  return use("bardiche")

func can_mask()
  return can_use("mask") & (foe ! nagaraja) & can_activate()

func should_mask()
  return can_mask() & is_boss & foe_distance <= C.melee_range & !disable_debuffs & can_debuff()

func mask()
  Tracer.span("mask")
  equip_R("mask")
  return use("mask")

// TODO: Need to extract `use`, `lock` and `equip_` before.
func can_summon()
  return (summon.GetId() ! "cinderwisp" | lock="fire_talisman") & can_use("fire_talisman") & can_activate()

func should_summon()
  return (foe_id ! "poena") & can_summon()

func summon()
  Tracer.span("summon")
  set_lock("fire_talisman", C.fire_talisman_frames)
  equip_R("fire talisman")
  return use("fire_talisman")

func unsummon()
  Tracer.span("unsummon")
  ?summon.count > 0
    equip_R("fire talisman")
    return use("fire_talisman")
  return false

func can_cinder()
  return summon.GetId() = "cinderwisp" & can_use("cinderwisp") & can_activate()

func should_cinder()
  return is_boss & can_cinder() &
  ^(summon.GetVar("ignition", 0) >=
  ^C.max_ignition_stacks | foe_ehp <=
  ^C.max_ignition_stacks * C.cinderwisp_dmg)

func cinder()
  Tracer.span("cinder")
  activate cinderwisp
  return true

func use_abilities()
  Tracer.span("use_abilities")
  ?should_cinder()
    return cinder()
  ?should_mask()
    return mask()
  ?should_hammer()
    return hammer()
  ?should_smite()
    return smite()
  ?should_bard()
    return bardiche()
  ?should_slap()
    return slap()
  return false

/*==================== INTERNALS ====================*/
var elem_types = ["sword", "big sword", "wand","shield", "crossbow", "staff", "hammer"]
var all_2h_types = [
  "bardiche", "arm", "blade", "heavy hammer", "repeating",
  "staff", "quarterstaff", "shovel", "crossbow"
]
var ranged_2h_types = ["repeating", "crossbow", "staff"]
var al_elems = ["aether", "fire", "ice", "poison", "vigor"]
var aa_st_types = []
var aa_aoe_types = []
var all_items = [/* NOTE:
hash, [weapon1, weapon2,], hash, [weapon3], ...
for example:
sword-aether-stats, [aether sword D],
hammer-fire-mod, [fire hammer dF],
wand-default, [stone wand + 10],
*/]

func _prepare_items()
   // [type, [elem, s1, sn], [elem2...]]
  for item_type : C.elemental_items
    ?item_type.Count() > 1
      var ty = item_type[0]
      // For each element..
      for i = 1 .. item_type.Count() - 1
        var suffixes = item_type[i]
        ?suffixes.Count() > 1
          // Suffixes: ["elem", "s1", "sn"]
          _categorize_item(ty, suffixes)
  for a : [
  ^[C.for_melee_single_target, aa_st_types],
  ^[C.for_melee_aoe, aa_aoe_types]]
    var source = a[0]
    var dest = a[1]
    ?source.Contains("heavy hammer")
      dest.Add("heavy hammer")
    ?source.Contains("hammer")
      dest.Add("hammer")
    for w : source
      ?!(w = "hammer")
        dest.Add(w)

func _categorize_item(ty, suffixes)
  var elem = suffixes[0]
  for j = 1 .. suffixes.Count() - 1
    var suffix = suffixes[j]
    ?is(elem, "default")
      add_item(hash([ty, "default"]), suffix)
    :
      var purpose = get_purpose(suffix)
      var full_name = string.Join(" ", [elem, ty, suffix])
      var h = hash([ty, elem, purpose])
      add_item(h, full_name)

// TODO: Move to utils.
func hash(parts)
  return string.Join("-", parts)

var elem_mods = ["f", "F", "i", "I", "p", "P", "h", "L", "u", "U"]

func get_purpose(suffix)
  ?string.Size(suffix) > 1 & elem_mods.Contains(string.Sub(suffix, 1, 1))
    return "mod"
  return "stats"

func add_item(hash, _name)
  var idx = all_items.IndexOf(hash)
  var arr
  ?idx = -1
    arr = [_name]
    all_items.Add(hash)
    all_items.Add(arr)
  :
    arr = all_items[idx + 1]
    ?!arr.Contains(_name)
      arr.Add(_name)

var all_statuses = [
  ["berserk", "Berserk", "+"],
  ["smite", "Smite", "+"],
  ["pick_pocket", "Pickpocket", "+"],
  ["vampiric", "Vamp", "+"],
  ["lucky_crit", "CritUp", "+"],
  ["lucky_mult", "CritMultUp", "+"],
  ["strenght", "Str", "+"],
  ["invisibility", "Invis", "+"],
  ["debuff_damage", "DmgDown", "-"],
  ["debuff_duration_damage", "DmgDown", "-"],
  ["spider_debuff_damage", "DmgDown", "-"],
  ["dysangelos_debuff_damage", "DmgDown", "-"],
  ["puff_debuff_damage", "DmgDown", "-"],
  ["debuff_yeti_chill", "AtkSlow", "-"],
  ["debuff_attack_speed", "AtkSlow", "-"],
  ["debuff_move_speed", "MoveSlow", "-"],
  ["debuff_chill", "Chill", "-"],
  ["stun", "Stun", "-"],
  ["pallas_phase2_debuff", "RangeDown", "-"],
  ["debuff_dot", "FireDoT", "-"],
  ["ignition", "Ignition", "-"]
]
var status_uids = []

func _prepare_statuses()
  for info : all_statuses
    status_uids.Add(info[0])

var my_buffs = []
var my_debuffs = []
var unk_effects = []
var pickpocket_stacks = 0
var smite_stacks = 0
var stunned = false
var aspd_down = false
var lucky_crit = false

func _update_my_effects()
  my_buffs.Clear()
  my_debuffs.Clear()
  // unk.effects are cleared at the end of loop.
  pickpocket_stacks = 0
  smite_stacks = 0
  stunned = false
  aspd_down = false
  lucky_crit = false
  for s : [buffs.string, debuffs.string]
    // Format: *:name:count:duration,...
    var splt = string.Split(s, ":", ",", false)
    var arr_size = splt.Count()
    ?arr_size > 0
      // Iterate over names (2nd field).
      for i = 1 .. arr_size - 3
        _parse_status(splt, i)
        i = i + 3

var ignore_statuses = [
  "quarterstaff_buff_attack_speed",
  "quarterstaff_buff_stun",
  "bardiche_buff_aoe_chance",
  "bardiche_buff_crit_chance",
  "bardiche_buff_crit_mult",
  "bardiche_buff_move_speed",
]
var aspd_debuffs = [
  "debuff_chill", "debuff_attack_speed",
  "debuff_yeti_chill",
]
var buff_template = "{0}({1}) {2}"

func _parse_status(splt, i)
  var uid = splt[i]
  var idx = status_uids.IndexOf(uid)
  ?idx = -1
    ?!ignore_statuses.Contains(uid) & !unk_effects.Contains(uid)
      unk_effects.Add(uid)
    return
  var info = all_statuses[idx] // uid,name,+/-
  var num = int.Parse(splt[i+1])
  var dur = int.Parse(splt[i+2])
  var _name = string.Format(buff_template, info[1], num, time.FormatDigital(dur))
  ?info[2] = "+"
    my_buffs.Add(_name)
  :
    my_debuffs.Add(_name)
  ?is(uid, "stun")
    stunned = true
  :?is(uid, "pick_pocket")
    pickpocket_stacks = num
  :?is(uid, "smite")
    smite_stacks = num
  :?aspd_debuffs.Contains(uid)
    aspd_down = true
  :?is(uid, "lucky_crit") & loc = Rocky & foe_id ! "acronian_scout"
    lucky_crit = true

func foe_buff(uid)
  return get_foe_effect(foe.buffs.string, uid)

func foe_debuff(uid)
  return get_foe_effect(foe.debuffs.string,uid)

func chill_delay()
  return 7 * foe_debuff("debuff_chill")

func get_foe_effect(str, uid)
  ?!(str = uid)
    return 0
  ?is(uid, "adaptive_defense")
    for s:string.Split(str, ":", ",", false)
      // Fuzzy match to get which defense it is.
      ?s = "adaptive_defense"
        return string.Split(s, "_", false)[2]
  // icon:uid:stacks:duration,...
  var splt = string.Split(str, ":", ",", false)
  var i = splt.IndexOf(uid)
  ?is(uid, "stun")
    // Duration.
    return int.Parse(splt[i+2])
  // Stacks.
  return int.Parse(splt[i+1])

var foe_elem = "default"
func get_foe_weak_elem()
  ?foe = aether
    foe_elem = "aether"
    return "vigor"
  ?foe = fire
    foe_elem = "fire"
    return "aether"
  ?foe = ice
    foe_elem = "ice"
    return "fire"
  ?foe = poison
    foe_elem = "poison"
    return "ice"
  ?foe = vigor
    foe_elem = "vigor"
    return "poison"
  foe_elem = "default"
  return "default"

// TODO: Move to constants.
var all_abilities = [
  "mind", "hammer", "bardiche", "blade",
  "skeleton_arm", "mask", "fire_talisman",
  "cinderwisp", "quarterstaff", "dash", "bash",
]
var move_r = ["quarterstaff", "bash", "dash"]
var cooldowns = ["mind", 0]
var abilities = ["mind", false]
func _prepare_abilities()
  for r : C.useable_abilities
    ?!all_abilities.Contains(r)
      Debugger.panic("Unknown ability: " + r)
    ?!abilities.Contains(r)
      HashTable.set(cooldowns, r, 0)
      HashTable.set(abilities, r, false)

var can_mind = false
func _update_abilities()
  for i = 0 .. abilities.Count() - 2
    var r = abilities[i]
    var cd = item.GetCooldown(r)
    HashTable.set(cooldowns, r, cd)
    HashTable.set(abilities, r, cd <= 0)
    ?is(r, "mind")
      can_mind = cd <= 0
    i++

func disable_r(ability)
  ?C.useable_abilities.Contains(ability)
    HashTable.set(abilities, ability, false)
  return true

// TODO: Move to own file.
func is(s1, s2)
  ?!s1 | !s2
    return false
  return string.Equals(s1, s2)

// TODO: Move to config.
var weapon_ranges = [
  "sword", 5,
  "hammer", 5,
  "quarterstaff", 5,
  "big sword", 6,
  "arm", 6,
  "heavy hammer", 7,
  "bardiche", 9,
  "staff", 10,
  "blade", 11,
  "wand", 20,
  "heavy crossbow", 22,
  "repeating", 22,
  "crossbow", 22
]
var melee_aoe_range = 5
var ranged_range = 20
func _prepare_ranges()
  var a = C.for_melee_single_target
  ?a.Count() > 0
    C.melee_range = HashTable.get(weapon_ranges, a[0])+1
  a = C.for_melee_aoe
  ?a.Count() > 0
    melee_aoe_range = HashTable.get(weapon_ranges,a[0])+1
  a = C.for_ranged_aoe
  ?a.Count() > 0
    ranged_range = HashTable.get(weapon_ranges, a[0])+1

func _update_lock()
  ?stunned
    set_lock("stun", 0)
  :?lock
    ?is(lock, "stun") | lock_timer <= 0
      lock = false
    :
      lock_timer--
  :
    lock_timer = 0

var at_boss = false // To disable default fight.
// == PLAYER STATUS ==
var low_hp = false
var can_aoe = false
var found = false
var found_type = false
// == ABILITIES ==
var lock = false
var lock_timer = false
var free_mind = false
// == FOE STATUS ==
var weak_elem = "default"
var foe_ehp = 0
var is_boss = false
var phys_immune = false
var foe_id = false
var foe_state = false
var loc_stars = false
var foe_distance = 99
var foe_count = false
var foe_time = false
var foe_armor = false
var player_armor = 0

// Done because accessing variables in cheaper than accessing properties.
func _update_game_state()
  _equip_L = false
  _equip_R = false
  found = false
  found_type = false
  excluded_items = false
  weak_elem = get_foe_weak_elem()
  foe_id = foe.id
  disable_debuffs = foe.buffs.count > 0 & (foe_buff("poena_mirror") | foe_buff("buff_protection"))
  low_hp = hp < (maxhp * C.low_hp_threshold)
  foe_ehp = foe.armor + foe.hp
  is_boss = (foe = boss)
  phys_immune = (foe = immune_to_physical)
  can_aoe = (foe.count >= C.aoe_threshold)
  foe_state = foe.state
  loc_stars = loc.stars
  foe_distance = foe.distance
  foe_count = foe.count
  foe_time = foe.time
  foe_armor = foe.armor
  player_armor = armor
  Tracer.spans.Clear()

// Reset/update dynamic global vars.
func handle_dynamic_global_vars()
  SafeMean.handle()
  _update_game_state()
  _update_my_effects()
  _update_abilities()
  _update_lock()

// == TRACKING ==
func draw_ui()
  var x = 1
  var y = 23
  ?C.ui_show_debug
    y = 21
  ?C.ui_show_statuses
    ?C.ui_show_debug
      >`@x@,@y@,#F008B2,? @string.Join(", ", unk_effects)@
      y++
    >`@x@,@y@,#FE6800,- @string.Join(", ", my_debuffs)@
    >`@x@,@y+1@,#00A300,+ @string.Join(", ", my_buffs)@
    ?!C.ui_show_debug
      >`@x@,@y+2@,@Colors.grey@,@loc_stars@* @time.FormatDigital(totaltime)@/@time.FormatDigital(loc.averageTime)@
  ?C.ui_show_cd
    y = 6
    for r : all_abilities
      ?!move_r.Contains(r) & r!"fire_talisman" & abilities.Contains(r)
        var cd = get_cd(r)
        ?is(r, "skeleton_arm")
          r = "arm"
        :?is(r, "cinderwisp")
          r = "cinder"
        >`@x@,@y@,#@Colors.cd(cd)@,@string.Capitalize(r)@ @time.FormatDigital(cd)@
        y++
    >`@x@,@y@,#@Colors.cd(get_cd("quarterstaff"))@,QS
    ?abilities.Contains("bash")
      >`@x+2@,@y@,@Colors.grey@,/
      >`@x+3@,@y@,#@Colors.cd(get_cd("bash"))@,B
    ?abilities.Contains("dash")
      >`@x+4@,@y@,@Colors.grey@,/
      >`@x+5@,@y@,#@Colors.cd(get_cd("dash"))@,D
  ?C.ui_show_debug
    x = 1
    y = 15
    ?foe
      ?string.Size(foe.buffs.string) > 0
        >`@x@,@y@,@Colors.grey@,@foe.buffs.string@
      >`@x@,@y+1@,@Colors.grey@,id: @foe_id@
      >`@x@,@y+2@,@Colors.grey@,S: @foe_state@,T: @foe_time@
      var c = foe_debuff("debuff_chill")
      >`@x@,@y+3@,@Colors.grey@,Chill: @c@/@c*7@
      >`@x@,@y+4@,@Colors.grey@,Dist: @foe_distance@
      >`@x@,@y+5@,@Colors.grey@,Count: @foe_count@
    y = 24

    var frame_time = math.BigNumber(0)
    for ft:frame_times
      frame_time.Add(ft)
    ?frame_time = 0 | frame_times.Count() = 0
      return false
    var info = "ms: " + frame_time.Div(frame_times.Count()).ToString()
    ?lock
      info = info + ", L: " + lock + " (" + lock_timer + ")"
    >`@x@,@y@,#blue,@info@

    >`@x@,@y+1@,@Colors.grey@,@foe@

    var _weapon = " (L)"
    x = screen.w - 10
    y = 23
    ?_equip_L
      x = x - string.Size(_equip_L)
      _weapon = _equip_L + _weapon
    >`@x@,@y@,#blue,@_weapon@
    _weapon = " (R)"
    x = screen.w - 10
    ?_equip_R
      x = x - string.Size(_equip_R)
      _weapon = _equip_R + _weapon
    >`@x@,@y+1@,#blue,@_weapon@

    Debuger.display(2)
    Tracer.display()

// == TRACKING ==
// hp, state, time, chill, dist, L, R.
var tracked = [-1, -1, -1, -1, -1, "", ""]
func track_hits()
  var hp_diff = tracked[0] - hp
  ?hp_diff > 0
    var y = 14
    var x = 55
    >`@x@,@y@,#red,Got hit!
    >`@x@,@y+1@,Last frame info:
    >`@x@,@y+2@,hp=@tracked[0]@ (diff=@hp_diff@)
    >`@x@,@y+3@,state=@tracked[1]@
    >`@x@,@y+4@,time=@tracked[2]@
    >`@x@,@y+5@,chill=@tracked[3]@
    >`@x@,@y+6@,dist=@tracked[4]@
    >`@x@,@y+7@,L=@tracked[5]@
    >`@x@,@y+8@,R=@tracked[6]@
    loc.Pause()
  tracked[0] = hp
  tracked[1] = foe_state
  tracked[2] = foe_time
  var chill = foe_debuff("debuff_chill")
  tracked[3] = chill+"/"+ 7*chill
  tracked[4] = foe_distance
  tracked[5] = _equip_L
  tracked[6] = _equip_R

func reset_loop()
  lock = false
  lock_timer = 0
  unk_effects.Clear()
  C.enable_hit_tracking = false
  at_boss = false
  naga_step = 0
  last_state = 0
  dysan_step = -1

// == TRACKING ==
var start_t = 0
var frame_times = []
var index = 0
start_t = time.msbn
/*==================== MAIN LOOP ====================*/
?loc.begin
  equip_L("quest")
  auto_equip_shield()
  _prepare_statuses()
  _prepare_items()
  _prepare_ranges()
  _prepare_abilities()
  Potion.create()
:?loc.loop
  Potion.create()
  reset_loop()

handle_dynamic_global_vars()

?ai.enabled & !ai.paused
  AAC.handle()
  progress()
:
  healwalk()

// == TRACKING ==
draw_ui()

?C.enable_hit_tracking
  track_hits()
?frame_times.Count() < 30
  frame_times.Add((time.msbn).Sub(start_t))
:
  frame_times[index] = ((time.msbn).Sub(start_t))
  index++
  ?index = frame_times.Count()
    index = 0
