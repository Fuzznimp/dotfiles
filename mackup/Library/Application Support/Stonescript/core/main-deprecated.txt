var C = import Stonescript/core/variables/constants
var Tracer = import Stonescript/observability/tracer
var Potion = import Stonescript/core/utils/potion
var Unmake = import Stonescript/core/utils/unmake
var SafeMean = import Stonescript/core/utils/safe-mean

/* Will exclusively use single-target ranged
against these enemies */
var must_ranged_foes = ["wasp", "wasp nest",
"mosquito", "huge mosquito"]

/* Used for scripted bosses, for `ranged_foes`,
or when `prefer_ranged` is true. */
var for_ranged_single_target = [
  "crossbow","repeating","wand"
]

/* Weapons to use for ranged AoE. Ranged AoE is
triggered by the same threshold as melee AoE.*/
var for_ranged_aoe = ["staff", "wand"]

/* Weapons to use against `immune_to_physical`
enemies. */
var for_phys_immune = ["staff", "wand"]

/* Full name of the shield with the highest
evade%, will be used to block big boss attacks
*/
var evade_shield = "vigor shield ah"

/* Script will try to stunlock these enemies
instead of using any other tactics. Supported:
poena, ceiling decorator, ice elemental. */
var do_stunlock = [
  "poena", "ceiling decorator"
]

// Full names of weapons to use for stunlocking
var stunlock_weapons=["socketed stone hammer +12"]

/* When to debuff bosses:
"never", "always", or "smite" (only if Smite
buff is active). */
var debuff_bosses = "never"

/* When to debuff regular enemies:
"never", "always", or "smite" (only if Smite
buff is active). */
var debuff_non_bosses = "smite"

/* If item is not listed here, its `R` ability
won't be used. Supported: dash, bash,
bardiche, hammer, blade, skeleton_arm, mask,
quarterstaff, fire_talisman, cinderwisp. */
var useable_abilities = [
  "dash","bash","mask","blade","hammer",
  "fire_talisman","bardiche","quarterstaff",
  "cinderwisp"
// "skeleton_arm"
]

/* Advanced: these are default values, change
them accordingly if you have speed enchants on
these weapons. */
var hammer_frames = 14
var bardiche_frames = 22

/* `dmg * (crit_mult + base_crit_mult)`,
script won't use the bardiche ability if
non-boss's HP is lower than twice this damage*/
var bardiche_dmg = 52 * (10.8+2)

/* Fraction of HP to consider low. When on low
HP, will prioritize `ah` shield and `dL` weapon
over foe's elemental weakness.
If 1, will always try to lifesteal to max
  (useful for clearing zones with full HP).
If 0, will never force lifesteal. */
var low_hp_threshold = 1

/* Switch to 1h+shield against non-boss foes
when `low_hp_threshold` is reached */
var use_shield_on_low_hp = false

var max_chill_stacks = 6

/* When to use Cinder ability (if listed in
`useable_abilities`). Will use at max_stacks,
or if boss's HP is lower than stacks * dmg. */
var max_ignition_stacks = 10
var cinderwisp_dmg = 96

var smite_threshold = 7
var smite_damage = 100
// Enable smiting two screens at once
var long_long_smite = true

// TODO: Move debug stuff into its own file.
var debug = true
var ui_show_cd = debug
var ui_show_statuses = debug
var ui_show_debug = debug
var enable_hit_tracking = false

// TODO: Move.
// If true, will use hatchet and shovel
var harvesting = false

/*********************
**     #Progress    **
*********************/
func progress()
  ?pickup.distance < 9
    // pick resources from the ground
    return equip_L("star") & equip_R("trisk")

  ?long_long_smite & smite_two_screens()
    return true

  ?healwalk()
    // no enemies nearby
    return true

  ?foe = explode
    return avoid_explosion()

  ?loc = caves
    check_stunlock()

  ?!is_boss & !at_boss
    // regular enemies
    free_mind = true
    return regular_fight()

  // Now handle bosses and minibosses

  Tracer.span("boss")
  disable_r("skeleton_arm")

  ?loc = rocky
    ?foe.id = "acronian_scout"
      Tracer.span("miniboss")
      disable_r("hammer")
      return fight_scout()
    return fight_dysan()

  :?loc = deadwood
    return fight_xyloalgia()

  :?loc = caves
    ?is(foe.id, "cool_bat")
      Tracer.span("miniboss")
      ?can_stunlock &
      ^do_stunlock.Contains("ceiling decorator")
        disable_r("mask")
        disable_r("blade")
        disable_r("bardiche")
        return stunlock()
      return auto_melee_miniboss()
    :
      return fight_bolesh()

  :?loc = fungus_forest_boss
    return fight_mushrooms()

  :?loc = mushroom & is(foe.id, "epic_snail")
    return disable_r("hammer") &
    ^disable_r("bash") & auto_melee_miniboss()

  :?loc = undead_crypt_boss
    return fight_pallas()

  :?loc = halls
    Tracer.span("miniboss")
    ?foe = ghost_tomb
      return melee("dps")
    :
      return ranged("aoe")

  :?loc = bronze_guardian
    return fight_bronze_guardian()

  :?loc = icy_ridge
    ?foe.id = "ice_elemental_elite"
      ?!at_boss
        Tracer.span("miniboss")
        ?can_stunlock & do_stunlock.Contains("ice elemental")
          disable_r("mask")
          disable_r("blade")
          disable_r("hammer")
          return stunlock()
        :
          return auto_melee_miniboss()
      :
        return ranged("aoe")
    return fight_hrimnir()

  :?loc = temple & is(foe.id, "acronian_cultist")
    Tracer.span("miniboss")
    excluded_items = "vigor"
    return auto_melee_miniboss()

  :?loc = nagaraja
    return fight_nagaraja()

  :
    dbg("Fighting unknown boss: " + foe.id)
    auto_melee_boss()

func healwalk()
  Tracer.span("healwalk")
  ?foe & (foe.distance < 23)
    ?hp < (maxhp / 4) & item.potion ! empty & (item.potion = "healing" | item.potion = "vampiric")
      activate potion
    return false // start combat instead
  :?harvesting & harvest.distance < 3 & _harvest()
    return true
  :?should_summon()
    return equip_L("trisk") & summon()
  :?can_qs_dash()
    return qs_dash()
  auto_equip_shield()
  ?hp < maxhp
    return equip_L("ouroboros")
  return equip_L("trisk")

func _harvest()
  ?loc = Rocky
    return equip_L("shovel")
  :?loc = Deadwood
    equip_R("hatchet")
    ?harvest.distance < 2
      use("hatchet")
    return true
  return false

func avoid_explosion()
  Tracer.span("explode")
  ?foe.distance < 5
    return try_evade()
  return auto_equip_L("melee", false) & equip_R("dashing")

var scrolling = 0
func smite_two_screens()
  var cd_ok = get_cd("blade") <= 0
  ?cd_ok & foe.count > 3
    scrolling++
    screen.Next()
  :
    scrolling = 0
    screen.ResetOffset()
  ?foe_ehp < 600 & foe_ehp > 0 & cd_ok & foe.distance < 25 & (foe.count > 5 | scrolling > 15)
    return smite()
  return scrolling > 0

/*****************
**    #Bosses   **
*****************/

func try_evade()
  Tracer.span("try_evade")
  ?can_mind
    set_lock("mind", 2)
    return backflip()
  return hard_block()

func hard_block()
  Tracer.span("hard_block")
  return equip_L("quest") & equip_R(evade_shield)

func evade_at(t)
  Tracer.span("evade_at")
  ?foe.time >= t
    return try_evade()
  ?foe.time < t & get_cd("mind")<=(t-foe.time)
    // abilities that would be interrupted
    ?foe.time > (t - bardiche_frames)
      disable_r("bardiche")
    ?foe.time > (t - hammer_frames)
      disable_r("hammer")
  return false

func soft_block()
  Tracer.span("soft_block")
  ?lock // don't interrupt abilities
    return false
  return equip_R(evade_shield)

func around(t)
  return foe.time > (t-2) & foe.time < (t+2)

func fight_scout()
  auto_melee_miniboss()

var last_state = 0
var dysan_step = -1
func fight_dysan()
  disable_r("skeleton_arm")
  var delay = chill_delay()
  var hit = 28
  ?loc.stars > 10
    hit = 22
  ?foe = phase1
    disable_r("blade")
    Potion.try_drink()
    ?(foe.state = 33 & foe.time = 23) |
    ^(foe.state = 32 & around(hit + delay))
      return soft_block()
  :?foe = phase2
    ?smite_at_exact() | dash_closer() | (foe.state = 33 & use_abilities())
      return true
    Tracer.span("match_element")
    found = find_weapon("melee",false,weak_elem,"stats","false")
    ?found
      equip_L(found)
    ?foe.state = 32 & around(58 + delay)
      return soft_block()
    found = false
    ?should_debuff()
      found = find_debuff_weapon("melee",
      ^false, debuff_elems[0], false)
    ?found
      return equip_R(found)
    return auto_equip_R("melee", false)
  :?foe = phase3
    disable_r("blade")
    weak_elem = "default"
    hit = 20 + math.Max(0, delay-6)
    // hammer him right as he gets armor
    ?foe.state=32 & foe.time>hit & dysan_step=0 & foe.distance > 10 & can_hammer()
      return hammer()
    // don't use element he's guarding against
    var resist = foe_buff("adaptive_defense")
    ?!(low_hp & is(resist, "vigor"))
      excluded_items = resist
    /* his attack order is cyclical, so we can
    dodge both the stun and the ray */
    ?(last_state = 32 & foe.state = 33) | (last_state = 33 & foe.state = 2) | (last_state = 2 & foe.state = 32)
      dysan_step++
    :?(foe.state!32) & (foe.state!33) & (foe.state!2)
      dysan_step = 0
    last_state = foe.state
    ?foe.state = 32 & dysan_step >= 6 & evade_at(hit)
      // dodge the stun
      dysan_step = 0
      return
    :?foe.state=115 & foe.time<=70 & evade_at(70)
      // dodge the ray, don't dash back into it
      return set_lock("boss", 7)
    :?foe.state = 32 & (dysan_step < 7) & around(48 + delay)
      return soft_block()
  auto_melee_boss()

func fight_xyloalgia()
  disable_r("skeleton_arm")
  var stunlock_poena = loc.stars > 5 & can_stunlock & do_stunlock.Contains("poena")
  ?foe = phase1
    ?Potion.fast_potion_bosses.Contains("xylo")
      Potion.try_drink()
    ?stunlock_poena
      // save abilities for poena
      disable_r("mask")
      disable_r("hammer")
      disable_r("blade")
      disable_r("bardiche")

    ?foe.state = 32 & evade_at(31 + chill_delay())
      return

    auto_melee_boss()
  :?foe = phase2
    ?unsummon()
      return
    excluded_items = "dU"
    ?stunlock_poena
      stunlock()

    // no stunlocking, avoid hitting the mirror
    :?(disable_debuffs & foe.hp>(foe.maxhp/4)) | (foe.state = 32 & foe.time = 41)
      hard_block()
    :
      auto_melee_boss()

func fight_bolesh()
  /* Get close, debuff/use abilities, then
  jump to ranged before the first melee bite,
  and continue shooting and blocking. */
  ?foe.state = 133 & (around(11) | around(16))
    //block the bite and don't move from ranged
    hard_block()

  :?foe.state = 142 & evade_at(60)
    // evade melee bite
    return

  :?can_mind & !foe_buff("spider_buff_damage")
    Potion.try_drink()
    return use_abilities() | auto_melee_boss()
  :
    auto_melee_boss()
    // ranged("single")

func fight_mushrooms()
  // thanks to user `fruloo` from the discord!
  var delay = chill_delay()
  ?foe = phase1
    ?Potion.fast_potion_bosses.Contains("mushrooms")
      Potion.try_drink()
    disable_r("skeleton_arm")
    ?foe.state = 32 & evade_at(46 + delay)
      return
    :?foe.state = 33 & foe.time=foe.distance+4
      return soft_block() // pellets
  :?foe = mushroom_boss_fat
    Potion.try_drink()
    ?foe.state = 32 & evade_at(26 + delay)
      return
  auto_melee_boss()

func fight_pallas()
  disable_r("skeleton_arm")
  ?foe = phase1
    ?Potion.fast_potion_bosses.Contains("pallas")
      Potion.try_drink()
    ?foe.state = 32 & foe.time = 68
      soft_block()
    :
      auto_melee_boss()
  :?foe = phase2
    Potion.try_drink()
    ?foe.count > 2
      return ranged("aoe") // deal with ghosts
    auto_melee_boss()

func fight_bronze_guardian()
  disable_r("blade")
  disable_r("bardiche")

  ?foe.state = 32 & foe.time = 33 & armor < foe.damage
    backflip() // dodge the hammer
  :?foe.state = 33 // hammer is down
    Potion.try_drink()
    auto_melee_boss()
  :
    ?foe.armor > 0 & foe.distance <= 21 & item.GetCooldown("hammer") <= 0 | item.GetCooldown("hammer") >= 647
      equip heavy hammer
      ?item.CanActivate()
        activate R
    :
      Potion.try_drink()
      ranged("single")

func fight_hrimnir()
  at_boss = true
  ?is_snowball_near() | (is_boss & foe.distance <= 6 & foe.state = 32 & around(23 + chill_delay()))
    // snowballs
    ?useable_abilities.Contains("fire_talisman")
      equip_L("fire talisman")
    soft_block()
  :?draw.GetSymbol(56, 13) = "o" | is_boss & foe.state = 133 // blowing
    ?foe.count > 1
      ranged("aoe")
    :
      ranged("single")
  :?is_boss & foe.state = 132 & foe.time > 24
    set_lock("boss", 2) // preparing to blow
    auto_melee_boss()
  :?is_boss & foe.state = 142 & foe.time > 83
    set_lock("boss", 2) // blowing + summons
    ?foe.count > 1
      ranged("aoe")
    :
      ranged("single")
  :?is_boss & foe.count = 1
    ?foe.armor > 0
      ?can_hammer()
        return hammer()
      return melee("dps")
    Potion.try_drink()
    auto_melee_boss()
  :?foe.distance < 8
    auto_melee()
  :
    auto_melee_boss()

var dists = [3, 4]
func is_snowball_near()
  var x = screen.FromWorldX(pos.x)
  var y = screen.FromWorldZ(pos.z)
  for dist : dists
    ?draw.GetSymbol(x+dist, y-3) = "(" & draw.GetSymbol(x+dist+1, y-3) = "_" & draw.GetSymbol(x+dist+2, y-3) = ")"
      return true
  return false

var naga_step = 0
func fight_nagaraja()
  disable_r("blade")
  ?Potion.fast_potion_bosses.Contains("naga")
    Potion.try_drink()
  var to_dodge = 1
  ?loc.stars > 10
    to_dodge = 4
  :?loc.stars > 5
    to_dodge = 2
  // dodge poison balls & plink away
  ?is_poison_near()
    ?naga_step <= to_dodge
      // we're still at range, use qs
      ?can_mind & foe.distance < 12
        naga_step = 0
        Potion.try_drink()
        auto_melee_boss()
      :
        naga_step++
        qs_dash()
    :
      // now we're in melee
      evade_naga()
  // boulder
  :?foe.state = 112 & foe.time = 59 & foe.distance < 10
    evade_naga()
  :?naga_step <= to_dodge
    /* to split-frame dash with quarterstaff,
    we need to be equipped with a 2h weapon the
    frame before. So we try not to use wands if
    possible. */
    ?use_abilities()
      return
    ?foe.state = 32 | foe.state = 33 | ((foe.state = 101 | foe.state = 112) & foe.time < 20)
      excluded_items = "wand"
      found =find_dps_weapon("ranged",false,true)
      ?found
        return equip_L(found)
      excluded_items = false
    ranged("single")
  :
    Potion.try_drink()
    auto_melee_boss()

func evade_naga()
  ?can_mind
    naga_step = 0
    return backflip() // dodge back
  :
    return soft_block() // try to block

func is_poison_near()
  var x = screen.FromWorldX(pos.x)
  var y = screen.FromWorldZ(pos.z)
  // long and mid range
  return draw.GetSymbol(x+2, y-6) = "(" |
  // melee
  ^(draw.GetSymbol(x+1, y-6) = "(")

/********************
**     #Combat    **
********************/

func regular_fight()
  Tracer.span("fight")
  ?must_ranged_foe()
    return ranged("single")
  ?foe = immune_to_ranged | foe = ranged
    return auto_melee()
  return auto_melee()

func must_ranged_foe()
  for enemy: must_ranged_foes
    ?foe = enemy
      return true

func auto_melee()
  Tracer.span("auto_m")
  ?use_abilities()
    return true
  :?can_aoe & foe.distance <= melee_aoe_range
    return melee("aoe")
  :?low_hp & use_shield_on_low_hp
    return melee("def")
  return melee("dps")

// mode: "dps" | "def" | "aoe"
func melee(mode)
  Tracer.span("m_" + mode)
  ?dash_closer()
    return true
  var aoe = is(mode, "aoe")
  ?Unmake.should_unmake()
    ?try_equip_unmake("melee", aoe)
      Tracer.span("unmaking")
      mode = "unmake"
      return approach()
  :?should_debuff()
    ?try_equip_debuff("melee", aoe)
      Tracer.span("debuff")
      mode = "debuff"
      return approach()
  ?is(mode, "def")
    auto_equip_L("melee", false)
    ?use_shield_on_low_hp
      auto_equip_shield()
    auto_equip_R("melee", false)
  :
    auto_equip_dps("melee", aoe)
  return approach()

func approach()
  var range = 6
  ?found_type
    range = get(weapon_ranges, found_type) + 1
  ?foe.distance > range
    Tracer.span("approach")
    // use a shield while walking closer
    ?!is_2hander(found_type)
      auto_equip_shield()
  return true

func dash_closer()
  Tracer.span("dash_closer")
  ?can_dash()
    return dash()
  :?should_qs_dash()
    return qs_dash()
  return false

func auto_ranged()
  Tracer.span("auto_r")

  ?for_ranged_single_target.Count() > 0 & smite_stacks > 6
    // NOTE: Will be an issue when multiple staves
    return ranged("staff")

  ?use_abilities()
    return true
  :?can_aoe & for_ranged_aoe.Count() > 0 & foe.distance <= ranged_range
    return ranged("aoe")
  :?for_ranged_single_target.Count() > 0
    return ranged("single")
  return auto_melee()

// mode: aoe | single | staff
func ranged(mode)
  Tracer.span("r_" + mode)
  var aoe = is(mode, "aoe")

  ?is(mode,"staff")
    return equip_L("staff")
  ?!aoe & must_ranged_foe() & for_ranged_single_target.Contains("repeating")
    return equip_L("repeating")
  ?Unmake.should_unmake()
    ?try_equip_unmake("melee", aoe)
      Tracer.span("unmaking")
      mode = "unmake"
  :?should_debuff()
    ?try_equip_debuff("ranged", aoe)
      return
  return auto_equip_dps("ranged", aoe)

func auto_melee_boss()
  Tracer.span("auto_m_boss")
  ?use_abilities() | dash_closer()
    return true
  ?Unmake.should_unmake() & try_equip_unmake("melee", false)
    Tracer.span("unmaking")
    return approach()
  :?should_debuff()
    ?try_equip_debuff("melee", false)
      Tracer.span("debuff")
      return approach()
  auto_equip_dps("melee", false)
  return approach()

func auto_melee_miniboss()
  Tracer.span("auto_m_miniboss")
  return disable_r("blade") & disable_r("mask") & disable_r("cinderwisp") & auto_melee()

var can_stunlock = do_stunlock.Count() > 0 & stunlock_weapons.Count() > 0

func check_stunlock()
  ?can_stunlock & foe.id ! "cool_bat" & do_stunlock.Contains("ceiling decorator")
    // save the stun for the bat
    disable_r("hammer")

func stunlock()
  Tracer.span("stunlock")
  disable_r("skeleton_arm")
  ?dash_closer()
    return true
  ?disable_debuffs
    return Potion.try_drink() & melee("dps")
  /* Now stunlock, and use abilities when
  it's safe */
  var stunned = foe_debuff("stun")
  ?(can_hammer() & foe.distance <= 17) | is(lock, "hammer")
    return hammer() // long stun
  :?(stunned > bardiche_frames + 10) & should_bard() | is(lock, "bardiche")
    return bardiche()
  :?stunned > 10
    ?should_cinder()
      return cinder()
    ?should_smite()
      return smite()
    ?should_mask()
      return mask()
  :?stunned <= 3
    ?get_cd("bash") <= 0 & foe.distance < 10 & foe_ehp > 100 & can_backflip()
      return backflip()
    ?can_qs_dash()
      return qs_dash()
  // default stunlock action
  found = false
  for it : stunlock_weapons
    ?!found & !(it = excluded_items) & !(it = foe_elem)
      found = it
  ?found
    equip_L(found)
  :
    equip_L(stunlock_weapons[0])
  found = false
  ?Unmake.should_unmake()
    found = find_unmake_weapon("melee",
    ^false, false)
  :?should_debuff()
    found = find_debuff_weapon("melee",
    ^false, debuff_elems[0], false)
  ?found
    equip_R(found)
  :
    auto_equip_R("melee", false)

/**********************
** #Weapon switching **
**********************/

var _equip_L = false
func equip_L(it)
  // sets global flag, so the next `get_item()`
  // in this frame won't return the same item
  _equip_L = it
  ?is_2hander(it) | is_2hander(found_type)
    return aac(it)
  equipL @it@
  return it

var _equip_R = false
func equip_R(it)
  // for debug
  _equip_R = it
  ?is_2hander(it) | is_2hander(found_type)
    // NOTE: Will be an issue when multiple staves
    ?is(found_type, "staff")
      return aac(C.ice_staff_di)
    return aac(it)
  equipR @it@
  return it

func is_2hander(ty)
  return ty & all_2h_types.Contains(ty)

// range: "melee" | "ranged"
// aoe: true/false
func auto_equip_L(range, aoe)
  Tracer.span("auto_eq_L")
  found = find_dps_weapon(range, aoe, true)
  ?found
    return equip_L(found)
  return false

// range: "melee" | "ranged"
// aoe: true/false
func auto_equip_R(range, aoe)
  Tracer.span("auto_eq_R")
  found = find_dps_weapon(range, aoe, false)
  ?found
    return equip_R(found)
  return auto_equip_shield()

func auto_equip_shield()
  Tracer.span("auto_eq_sh")
  found = false
  found_type = false
  ?low_hp
    found=get_item("shield", "vigor", "mod")
  ?!found
    found=get_item("shield",weak_elem,"stats")
  ?!found
    found=get_item("shield", "default", "")
  ?found
    return equip_R(found)
  return false

// range: "melee" | "ranged" ; aoe: true/false
func auto_equip_dps(range, aoe)
  Tracer.span("auto_eq_dps")
  found = find_dps_weapon(range, aoe, true)
  ?!found
    return false
  equip_L(found)
  ?is_2hander(found_type)
    return found
  found = find_dps_weapon(range, aoe, false)
  ?found
    return equip_R(found)
  return false

func find_dps_weapon(range, aoe, allow_2h)
  Tracer.span("find_dps_weapon")
  found = false
  ?low_hp
    // heal on low hp
    found = find_weapon(range, aoe,
    ^"vigor", "mod", allow_2h)
  ?!found
    // default case: match element
    found = find_weapon(range, aoe,
    ^weak_elem, "stats", allow_2h)
  Tracer.span(""+found)
  return found

func try_equip_debuff(range, aoe)
  Tracer.span("try_eq_debuff")
  found = false
  for elem:debuff_elems
    found = find_debuff_weapon(range, aoe,
    ^elem, !_equip_L)
    ?found
      ?!_equip_L
        equip_L(found)
        ?is_2hander(found_type)
          return true
      :?!_equip_R
        ?low_hp
          return auto_equip_R(range, aoe)
        return equip_R(found)
  ?_equip_L
    ?!_equip_R
      return auto_equip_R(range, aoe)
  :
    Tracer.span("no_debuff_weapon")
    return false
  return true

func find_debuff_weapon(range, aoe, elem, allow_2h)
  Tracer.span("find_debuff_wep")
  found = find_weapon(range, aoe, elem, "mod", allow_2h)
  ?!found & range = "melee" & !(foe = immune_to_ranged | foe = ranged)
    found = find_weapon("ranged", aoe, elem, "mod", allow_2h)
  return found

func try_equip_unmake(range, aoe)
  Tracer.span("try_eq_unmake")
  found = find_unmake_weapon(range,aoe,true)
  ?!found
    aoe = false
    found = find_unmake_weapon(range,aoe,true)
  ?!found
    Tracer.span("no_unmake_weapon")
    return false
  equip_L(found)
  ?is_2hander(found_type)
    return true
  ?low_hp
    return auto_equip_R(range, aoe)
  found = find_unmake_weapon(range,aoe,false)
  ?found
    return equip_R(found)
  return auto_equip_R()

func find_unmake_weapon(range, aoe, allow_2h)
  Tracer.span("find_unmake_wep")
  found = find_weapon(range, aoe,
  ^"aether", "mod", allow_2h)
  ?!found & range = "melee"
    found = find_weapon("ranged", aoe,
    ^"aether", "mod", allow_2h)
  return found

func find_weapon(range, aoe, elem, purpose, allow_2h)
  found = false
  found_type = false
  var types = get_preferred_types(range, aoe)
  for ty : types
    ?allow_2h | !is_2hander(ty)
      ?!elem_types.Contains(ty) & !is(purpose, "mod")
        found_type = ty
        return ty
      found = get_item(ty, elem, purpose)
      ?!found & purpose = "stats"
        // NOTE: Should probably remove this condition and call right away.
        ?!found
          found = get_item(ty, "default", "")
      ?found
        found_type = ty
        return found
  return false

func get_preferred_types(range, aoe)
  ?phys_immune |
  ^(can_aoe & foe = magic_vulnerability)
    return for_phys_immune
  var types = C.for_melee_single_target
  ?is(range, "melee")
    ?foe.armor > 0
      ?aoe
        types = aa_aoe_types
      :
        types = aa_st_types
    :?aoe
      types = C.for_melee_aoe
  :
    ?aoe
      types = for_ranged_aoe
    :
      types = for_ranged_single_target
  return types

var excluded_items = ""
func get_item(ty, elem, purpose)
  var h
  ?is(elem, "default")
    h = hash([ty, "default"])
  :
    h = hash([ty, elem, purpose])
  var items = try_get(all_items, h, false)
  ?!items | items.Count() = 0
    return false
  for it : items
    ?(!_equip_L | !is(it, _equip_L)) &
    ^(!excluded_items | !(it = excluded_items))
      return it
  return false



var only_dot = false
func can_debuff()
  only_dot = false
  ?disable_debuffs
    return false
  ?is_boss
    ?loc = Rocky // NOTE: Always debuff Scout & Dysan.
      return true
    ?is(debuff_bosses, "never")
      return false
    ?is(debuff_bosses,"smite") & smite_stacks=0
      ?can_be_debuffed("debuff_dot")
        only_dot = true // NOTE: Keep up the dot.
        return true
      return false
  ?!is_boss & (is(debuff_non_bosses, "never") | is(debuff_non_bosses,"smite") & smite_stacks=0)
    return false
  return true

var disable_debuffs = false
var debuff_elems = []

func should_debuff()
  ?!can_debuff()
    return false
  debuff_elems.Clear()
  ?can_be_debuffed("debuff_dot")
    debuff_elems.Add("fire")
    ?only_dot
      return true
  ?can_be_debuffed("debuff_chill")
    debuff_elems.Add("ice")
  ?can_be_debuffed("debuff_damage")
    debuff_elems.Add("poison")
  var c = debuff_elems.Count()
  ?c > 1 & foe = debuff_elems[0]
    var move = debuff_elems[0]
    debuff_elems.Emplace(0, debuff_elems[c-1])
    debuff_elems.Emplace(c-1, move)
  return c > 0

func can_be_debuffed(debuff_uid)
  ?(foe = "immune_to_" + debuff_uid)
    return false
  ?is(debuff_uid, "debuff_chill")
    var c = foe_debuff("debuff_chill")
    return c < max_chill_stacks
  return !foe_debuff(debuff_uid)

/********************
**    #Abilities   **
********************/

func get_cd(ability)
  return try_get(cooldowns, ability, 9999)

func allowed(ability)
  return try_get(abilities, ability, false)

func set_lock(tag, timer)
  ?!lock | (is(tag,"boss") & lock_timer < timer)
    lock = tag
    lock_timer = timer
  return true

func can_use(ability)
  ?lock
    return is(lock, ability)
  return allowed(ability)

func can_activate()
  return ai.enabled & item.CanActivate()

func use(ability)
  ?item.CanActivate(ability)
    activate R
  return true

func can_dash()
  return can_activate() & (can_use("dash") | can_use("bash") & !disable_debuffs)
  ^& foe.distance > 10 & foe.distance < 16

func dash()
  Tracer.span("dash")
  ?!disable_debuffs & can_use("bash")
    Tracer.span("bashing")
    return equip_R("bashing")
  :?can_use("dash")
    Tracer.span("dashing")
    return equip_R("dashing")
  return false

func can_qs_dash()
  return can_use("quarterstaff") &
  ^can_activate()

func should_qs_dash()
  return (foe.distance > 16 | foe.distance < 11 & foe.distance > 5) & can_qs_dash()

func qs_dash()
  Tracer.span("qs_dash")
  equip_L(C.quarterstaff_dash)
  return use("quarterstaff")

func can_backflip()
  return can_use("mind") & free_mind &
   // NOTE: Don't jump into the wall.
  ^screen.FromWorldX(pos.x) > 5

func backflip()
  Tracer.span("backflip")
  auto_equip_shield()
  return equip_L("mind")

func can_slap()
  return can_use("skeleton_arm") &
  ^!(foe.id = "ice_pillar") &
  ^foe.distance < 7 & !phys_immune &
  ^can_activate()

func should_slap()
  return can_slap() & foe_ehp <= C.arm_damage

func slap()
  Tracer.span("slap")
  ?pickpocket_stacks < C.max_pickpocket_stacks
    return aac("arm")
  equip_L("arm")
  return use("skeleton_arm")

func can_smite()
  return can_use("blade") &
  ^foe.distance <= 20 & (foe ! pallas) &
  ^can_activate()

func should_smite()
  return (is_boss | foe.count >= smite_threshold
  ^& foe_ehp <= smite_damage) & can_smite()

func smite()
  Tracer.span("smite")
  equip_L("blade")
  return use("blade")

func smite_at_exact()
  disable_r("blade")
  ?foe.hp<=smite_damage & get_cd("blade")<=0
    return smite()
  return false

func can_hammer()
  return can_use("hammer") & !phys_immune &
  ^foe.distance <= 21 & can_activate()

func should_hammer()
  ?!can_hammer()
    return false
  return is(lock, "hammer") |
  ^(is_boss | can_aoe & foe.distance<15)
  ^& (foe.armor > 0 | foe = spawner |
  ^can_debuff() &
  ^!(foe = immune_to_stun))

func hammer()
  Tracer.span("hammer")
  set_lock("hammer", hammer_frames)
  equip_L("heavy hammer")
  return use("hammer")

func can_bard()
  return can_use("bardiche") &
  ^foe.distance <= 9 & !phys_immune &
  ^can_activate()

func should_bard()
  return is(lock, "bardiche") | is_boss &
  ^!aspd_down & (foe_ehp >= (bardiche_dmg * 2)|
  ^foe_ehp < bardiche_dmg) & can_bard()

func bardiche()
  Tracer.span("bardiche")
  set_lock("bardiche", bardiche_frames)
  equip_L("bardiche")
  return use("bardiche")

func can_mask()
  return can_use("mask") &
  ^(foe ! nagaraja) & can_activate()

func should_mask()
  return can_mask() & is_boss & foe.distance <= C.melee_range
  ^& !disable_debuffs & can_debuff()

func mask()
  Tracer.span("mask")
  equip_R("mask")
  return use("mask")
/*
  Need to extract `use`, `lock` and `equip_` before.
*/
func can_summon()
  return (summon.GetId() ! "cinderwisp" |
  ^lock="fire_talisman") &
  ^can_use("fire_talisman") & can_activate()

func should_summon()
  return (foe.id ! "poena") & can_summon()

var fire_frames = 20

func summon()
  Tracer.span("summon")
  set_lock("fire_talisman", fire_frames)
  equip_R("fire talisman")
  return use("fire_talisman")

func unsummon()
  Tracer.span("unsummon")
  ?summon.count > 0
    equip_R("fire talisman")
    return use("fire_talisman")
  return false

func can_cinder()
  return summon.GetId() = "cinderwisp" &
  ^can_use("cinderwisp") & can_activate()

func should_cinder()
  return is_boss & can_cinder() &
  ^(summon.GetVar("ignition", 0) >=
  ^max_ignition_stacks | foe_ehp <=
  ^max_ignition_stacks * cinderwisp_dmg)

func cinder()
  Tracer.span("cinder")
  activate cinderwisp
  return true

func use_abilities()
  Tracer.span("use_abilities")
  ?should_cinder()
    return cinder()
  ?should_mask()
    return mask()
  ?should_hammer()
    return hammer()
  ?should_smite()
    return smite()
  ?should_bard()
    return bardiche()
  ?should_slap()
    return slap()
  return false

var runebow_aac_timer = 0
func runebow_aac(speed_normal, speed_berserk)
  ?runebow_aac_timer = 0
    equipL wand
    equip crossbow D aether

  ?buffs.string = "berserk"
    runebow_aac_timer = (runebow_aac_timer + 1) % speed_berserk
  :
    runebow_aac_timer = (runebow_aac_timer + 1) % speed_normal

var aac_tick = 1
func aac(weapon)
  Tracer.span("aac_" + weapon)
  _equip_L = weapon
  equip @weapon@
  ?!ai.idle
    return true
  ?is(lock, "hammer") |
  ^is(lock, "bardiche")
    return true
  ?weapon = "repeating" | weapon = C.ice_staff_di
    aac_tick--
    ?aac_tick = 0
      aac_tick = 2
      equip blade
      equip @weapon@
    return weapon
  ?weapon = C.aether_runebow_d | weapon = C.fire_runebow_d
    Tracer.span("runebow_aac")
    runebow_aac(21, 12)
  ?weapon = "wand" | weapon = "staff"
    return true
  equip wand
  equip @weapon@
  return weapon

/*********************
**     #Internals   **
*********************/
var elem_types = ["sword", "big sword", "wand",
"shield", "crossbow", "staff", "hammer"]
var all_2h_types = ["bardiche", "arm", "blade",
"heavy hammer", "repeating", "staff",
"quarterstaff", "shovel", "crossbow"]
var ranged_2h_types = ["repeating", "crossbow",
"staff"]
var al_elems = ["aether", "fire", "ice",
"poison", "vigor"]
var aa_st_types = []
var aa_aoe_types = []
var all_items = [/*
hash, [weapon1, weapon2,], hash, [weapon3], ...
for example:
sword-aether-stats, [aether sword D],
hammer-fire-mod, [fire hammer dF],
wand-default, [stone wand + 10],
*/]

func _prepare_items()
   // [type, [elem, s1, sn], [elem2...]]
  for item_type : C.elemental_items
    ?item_type.Count() > 1
      var ty = item_type[0]
      // for each element
      for i = 1 .. item_type.Count() - 1
        var suffixes = item_type[i]
        ?suffixes.Count() > 1
          // suffixes: ["elem", "s1", "sn"]
          _categorize_item(ty, suffixes)
  for a : [
  ^[C.for_melee_single_target, aa_st_types],
  ^[C.for_melee_aoe, aa_aoe_types]]
    var source = a[0]
    var dest = a[1]
    ?source.Contains("heavy hammer")
      dest.Add("heavy hammer")
    ?source.Contains("hammer")
      dest.Add("hammer")
    for w : source
      ?!(w = "hammer")
        dest.Add(w)

func _categorize_item(ty, suffixes)
  var elem = suffixes[0]
  for j = 1 .. suffixes.Count() - 1
    var suffix = suffixes[j]
    ?is(elem, "default")
      add_item(hash([ty, "default"]), suffix)
    :
      var purpose = get_purpose(suffix)
      var full_name = string.Join(" ",
      ^[elem, ty, suffix])
      var h = hash([ty, elem, purpose])
      add_item(h, full_name)

func hash(parts)
  return string.Join("-", parts)

var elem_mods = ["f", "F", "i", "I",
"p", "P", "h", "L", "u", "U"]

func get_purpose(suffix)
  ?string.Size(suffix) > 1 &
  ^elem_mods.Contains(string.Sub(suffix, 1, 1))
    return "mod"
  return "stats"

func add_item(hash, _name)
  var idx = all_items.IndexOf(hash)
  var arr
  ?idx = -1
    arr = [_name]
    all_items.Add(hash)
    all_items.Add(arr)
  :
    arr = all_items[idx + 1]
    ?!arr.Contains(_name)
      arr.Add(_name)

var all_statuses = [
  ["berserk", "Berserk", "+"],
  ["smite", "Smite", "+"],
  ["pick_pocket", "Pickpocket", "+"],
  ["vampiric", "Vamp", "+"],
  ["lucky_crit", "CritUp", "+"],
  ["lucky_mult", "CritMultUp", "+"],
  ["strenght", "Str", "+"],
  ["invisibility", "Invis", "+"],
  ["debuff_damage", "DmgDown", "-"],
  ["debuff_duration_damage", "DmgDown", "-"],
  ["spider_debuff_damage", "DmgDown", "-"],
  ["dysangelos_debuff_damage", "DmgDown", "-"],
  ["puff_debuff_damage", "DmgDown", "-"],
  ["debuff_yeti_chill", "AtkSlow", "-"],
  ["debuff_attack_speed", "AtkSlow", "-"],
  ["debuff_move_speed", "MoveSlow", "-"],
  ["debuff_chill", "Chill", "-"],
  ["stun", "Stun", "-"],
  ["pallas_phase2_debuff", "RangeDown", "-"],
  ["debuff_dot", "FireDoT", "-"],
  ["ignition", "Ignition", "-"]
]
var status_uids = []

func _prepare_statuses()
  for info : all_statuses
    status_uids.Add(info[0])

var my_buffs = []
var my_debuffs = []
var unk_effects = []
var pickpocket_stacks = 0
var smite_stacks = 0
var stunned = false
var aspd_down = false

func _update_my_effects()
  my_buffs.Clear()
  my_debuffs.Clear()
  // unk.effects are cleared at the end of loop
  pickpocket_stacks = 0
  smite_stacks = 0
  stunned = false
  aspd_down = false
  for s : [buffs.string, debuffs.string]
    // format: *:name:count:duration,...
    var splt = string.Split(s, ":", ",", false)
    var arr_size = splt.Count()
    ?arr_size > 0
      // iterate over names (2nd field)
      for i = 1 .. arr_size - 3
        _parse_status(splt, i)
        i = i + 3

var ignore_statuses = [
  "quarterstaff_buff_attack_speed",
  "quarterstaff_buff_stun",
  "bardiche_buff_aoe_chance",
  "bardiche_buff_crit_chance",
  "bardiche_buff_crit_mult",
  "bardiche_buff_move_speed",
]
var aspd_debuffs = [
  "debuff_chill", "debuff_attack_speed",
  "debuff_yeti_chill",
]
var buff_template = "{0}({1}) {2}"

func _parse_status(splt, i)
  var uid = splt[i]
  var idx = status_uids.IndexOf(uid)
  ?idx = -1
    ?!ignore_statuses.Contains(uid) &
    ^!unk_effects.Contains(uid)
      unk_effects.Add(uid)
    return
  var info = all_statuses[idx] // uid,name,+/-
  var num = int.Parse(splt[i+1])
  var dur = int.Parse(splt[i+2])
  var _name = string.Format(buff_template,
  ^info[1], num, time.FormatDigital(dur))
  ?info[2] = "+"
    my_buffs.Add(_name)
  :
    my_debuffs.Add(_name)
  ?is(uid, "stun")
    stunned = true
  :?is(uid, "pick_pocket")
    pickpocket_stacks = num
  :?is(uid, "smite")
    smite_stacks = num
  :?aspd_debuffs.Contains(uid)
    aspd_down = true

func foe_buff(uid)
  return get_foe_effect(foe.buffs.string, uid)

func foe_debuff(uid)
  return get_foe_effect(foe.debuffs.string,uid)

func chill_delay()
  return 7 * foe_debuff("debuff_chill")

func get_foe_effect(str, uid)
  ?!(str = uid)
    return 0
  ?is(uid, "adaptive_defense")
    for s:string.Split(str, ":", ",", false)
      // fuzzy match to get which defense it is
      ?s = "adaptive_defense"
        return string.Split(s, "_", false)[2]
  // icon:uid:stacks:duration,...
  var splt = string.Split(str, ":", ",", false)
  var i = splt.IndexOf(uid)
  ?is(uid, "stun")
    // duration
    return int.Parse(splt[i+2])
  // stacks
  return int.Parse(splt[i+1])

var foe_elem = "default"

func get_foe_weak_elem()
  ?foe = aether
    foe_elem = "aether"
    return "vigor"
  ?foe = fire
    foe_elem = "fire"
    return "aether"
  ?foe = ice
    foe_elem = "ice"
    return "fire"
  ?foe = poison
    foe_elem = "poison"
    return "ice"
  ?foe = vigor
    foe_elem = "vigor"
    return "poison"
  foe_elem = "default"
  return "default"

var all_abilities = [
  "mind", "hammer", "bardiche", "blade",
  "skeleton_arm", "mask", "fire_talisman",
  "cinderwisp", "quarterstaff", "dash", "bash",
]
var move_r = ["quarterstaff", "bash", "dash"]
var cooldowns = ["mind", 0]
var abilities = ["mind", false]
func _prepare_abilities()
  for r : useable_abilities
    ?!all_abilities.Contains(r)
      panic("Unknown ability: " + r)
    ?!abilities.Contains(r)
      set(cooldowns, r, 0)
      set(abilities, r, false)

var can_mind = false
func _update_abilities()
  for i = 0 .. abilities.Count() - 2
    var r = abilities[i]
    var cd = item.GetCooldown(r)
    set(cooldowns, r, cd)
    set(abilities, r, cd <= 0)
    ?is(r, "mind")
      can_mind = cd <= 0
    i++

func disable_r(ability)
  ?useable_abilities.Contains(ability)
    set(abilities, ability, false)
  return true

func get(dict, k)
  var idx = dict.IndexOf(k)
  ?idx = -1
    panic("Bad dict key: k=" + k)
  return dict[idx + 1]

func try_get(dict, k, default)
  var idx = dict.IndexOf(k)
  ?idx = -1
    return default
  return dict[idx + 1]

func set(dict, k, v)
  var idx = dict.IndexOf(k)
  ?idx = -1
    dict.Add(k)
    dict.Add(v)
  :
    dict[idx + 1] = v
  return true

func is(s1, s2)
  ?!s1 | !s2
    return false
  return string.Equals(s1, s2)

var weapon_ranges = ["sword", 5, "hammer", 5,
"quarterstaff", 5, "big sword", 6, "arm", 6,
"heavy hammer", 7, "bardiche", 9, "staff", 10,
"blade", 11, "wand", 20, "heavy crossbow", 22,
"repeating", 22, "crossbow", 22]
var melee_aoe_range = 5
var ranged_range = 20
func _prepare_ranges()
  var a = C.for_melee_single_target
  ?a.Count() > 0
    C.melee_range = get(weapon_ranges, a[0])+1
  a = C.for_melee_aoe
  ?a.Count() > 0
    melee_aoe_range = get(weapon_ranges,a[0])+1
  a = for_ranged_aoe
  ?a.Count() > 0
    ranged_range = get(weapon_ranges, a[0])+1

func _update_lock()
  ?stunned
    set_lock("stun", 0)
  :?lock
    ?is(lock, "stun") | lock_timer <= 0
      lock = false
    :
      lock_timer--
  :
    lock_timer = 0

var at_boss = false // to disable default fight
// player status
var low_hp = false // hp < (maxhp * threshold)
var can_aoe = false
var found = false
var found_type = false
var weak_elem = "default"
// abilities
var lock = false
var lock_timer = false
var free_mind = false
// foe status
var foe_ehp = 0 // foe.armor + foe.hp
var is_boss = false // foe = boss
var phys_immune = false // immune to physical

func _update_game_state()
  _equip_L = false
  _equip_R = false
  found = false
  found_type = false
  excluded_items = false
  weak_elem = get_foe_weak_elem()
  disable_debuffs = foe.buffs.count > 0 & (foe_buff("poena_mirror") | foe_buff("buff_protection"))
  low_hp = hp < (maxhp * low_hp_threshold)
  foe_ehp = foe.armor + foe.hp
  is_boss = (foe = boss)
  phys_immune = (foe = immune_to_physical)
  can_aoe = (foe.count >= C.aoe_threshold)
  // %start_dev%
  Tracer.spans.Clear()
  // %end_dev%

func prelude()
  // reset/update dynamic global vars
  SafeMean.handle()
  _update_game_state()
  _update_my_effects()
  _update_abilities()
  _update_lock()

func panic(e)
  >`20,5,#red,@e@
  loc.Pause()

// %start_dev%
var errors = []
func dbg(e)
  ?ui_show_debug
    ?!errors.Contains(e)
      errors.Add(e)

// %end_dev%

var gray = "#7A8F93"
func draw_ui()
  var x = 1
  var y = 23
  ?ui_show_debug
    y = 21
  ?ui_show_statuses
    ?ui_show_debug
      >`@x@,@y@,#F008B2,? @string.Join(", ", unk_effects)@
      y++
    >`@x@,@y@,#FE6800,- @string.Join(", ", my_debuffs)@
    >`@x@,@y+1@,#00A300,+ @string.Join(", ", my_buffs)@
    ?!ui_show_debug
      >`@x@,@y+2@,@gray@,@loc.stars@* @time.FormatDigital(totaltime)@/@time.FormatDigital(loc.averageTime)@
  ?ui_show_cd
    y = 6
    for r : all_abilities
      ?!move_r.Contains(r) & r!"fire_talisman" & abilities.Contains(r)
        var cd = get_cd(r)
        ?is(r, "skeleton_arm")
          r = "arm"
        :?is(r, "cinderwisp")
          r = "cinder"
        >`@x@,@y@,#@colorize(cd)@,@string.Capitalize(r)@ @time.FormatDigital(cd)@
        y++
    >`@x@,@y@,#@colorize(get_cd("quarterstaff"))@,QS
    ?abilities.Contains("bash")
      >`@x+2@,@y@,@gray@,/
      >`@x+3@,@y@,#@colorize(get_cd("bash"))@,B
    ?abilities.Contains("dash")
      >`@x+4@,@y@,@gray@,/
      >`@x+5@,@y@,#@colorize(get_cd("dash"))@,D
  ?ui_show_debug
    x = 1
    y = 15
    ?foe
      ?string.Size(foe.buffs.string) > 0
        >`@x@,@y@,@gray@,@foe.buffs.string@
      >`@x@,@y+1@,@gray@,id: @foe.id@
      >`@x@,@y+2@,@gray@,S: @foe.state@,T: @foe.time@
      var c = foe_debuff("debuff_chill")
      >`@x@,@y+3@,@gray@,Chill: @c@/@c*7@
      >`@x@,@y+4@,@gray@,Dist: @foe.distance@
      >`@x@,@y+5@,@gray@,Count: @foe.count@
    y = 24
    // %start_dev%
    var frame_time = 0
    for ft:frame_times
      frame_time = frame_time + ft
    ?frame_time = 0
      return false
    var info = "ms: " + frame_time/frame_times.Count()
    ?lock
      info = info + ", L: " + lock + " (" + lock_timer + ")"
    >`@x@,@y@,#blue,@info@
    // %end_dev%
    >`@x@,@y+1@,@gray@,@foe@
    var _weapon = " (L)"
    x = screen.w - 10
    y = 23
    ?_equip_L
      x = x - string.Size(_equip_L)
      _weapon = _equip_L + _weapon
    >`@x@,@y@,#blue,@_weapon@
    _weapon = " (R)"
    x = screen.w - 10
    ?_equip_R
      x = x - string.Size(_equip_R)
      _weapon = _equip_R + _weapon
    >`@x@,@y+1@,#blue,@_weapon@

    // %start_dev%
    // TODO: Extract
    var ey = 2
    for err : errors
      >`20,@ey@,#red,@err@
      ey++
    ?Tracer.enable_tracer
      Tracer.display_trace()
    // %end_dev%

func colorize(cd)
  ?cd > 0
    return "red"
  return "green"

// %start_dev%
// hp, state, time, chill, dist, L, R
var tracked = [-1, -1, -1, -1, -1, "", ""]
func track_hits()
  var hp_diff = tracked[0] - hp
  ?hp_diff > 0
    var y = 14
    var x = 55
    >`@x@,@y@,#red,Got hit!
    >`@x@,@y+1@,Last frame info:
    >`@x@,@y+2@,hp=@tracked[0]@ (diff=@hp_diff@)
    >`@x@,@y+3@,state=@tracked[1]@
    >`@x@,@y+4@,time=@tracked[2]@
    >`@x@,@y+5@,chill=@tracked[3]@
    >`@x@,@y+6@,dist=@tracked[4]@
    >`@x@,@y+7@,L=@tracked[5]@
    >`@x@,@y+8@,R=@tracked[6]@
    loc.Pause()
  tracked[0] = hp
  tracked[1] = foe.state
  tracked[2] = foe.time
  var chill = foe_debuff("debuff_chill")
  tracked[3] = chill+"/"+ 7*chill
  tracked[4] = foe.distance
  tracked[5] = _equip_L
  tracked[6] = _equip_R
// %end_dev%

func reset_loop()
  lock = false
  lock_timer = 0
  unk_effects.Clear()
  enable_hit_tracking = false
  at_boss = false
  naga_step = 0
  last_state = 0
  dysan_step = -1

func handle_aac()
  ?item.left.state = 3
    equipL wand *0
  ?item.right.state = 3
    equipR shield *0

// %start_dev%
var start_t = 0
var frame_times = []
var index = 0
start_t = time.ms
// %end_dev%
?loc.begin
  equip_L("quest")
  auto_equip_shield()
  _prepare_statuses()
  _prepare_items()
  _prepare_ranges()
  _prepare_abilities()
  Potion.create()
:?loc.loop
  Potion.create()
  reset_loop()
prelude()
?ai.enabled & !ai.paused
  handle_aac()
  progress()
:
  healwalk()
draw_ui()
// %start_dev%
?enable_hit_tracking
  track_hits()
?frame_times.Count() < 30
  frame_times.Add(time.ms-start_t)
:
  frame_times.Emplace(index, time.ms-start_t)
  index++
  ?index = frame_times.Count()
    index = 0
// %end_dev%
